"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = exports.coerceUserCreateReviewRequestOptions = exports.coerceUserCreatePullRequestOptions = exports.REVIEW_PR_COMMAND = exports.CREATE_PR_COMMAND = void 0;
const rest_1 = require("@octokit/rest");
const git = require("./handle-git-dir-change");
const __1 = require("../");
const logger_1 = require("../logger");
const yargs = require("yargs");
exports.CREATE_PR_COMMAND = 'pr';
exports.REVIEW_PR_COMMAND = 'review';
/**
 * map yargs to user pull request otions
 */
function coerceUserCreatePullRequestOptions() {
    return {
        upstreamRepo: yargs.argv.upstreamRepo,
        upstreamOwner: yargs.argv.upstreamOwner,
        message: yargs.argv.message,
        description: yargs.argv.description,
        title: yargs.argv.title,
        branch: yargs.argv.branch,
        force: yargs.argv.force,
        primary: yargs.argv.primary,
        maintainersCanModify: yargs.argv.maintainersCanModify,
        fork: yargs.argv.fork,
        labels: yargs.argv.labels,
        logger: logger_1.logger,
        filesPerCommit: yargs.argv.filesPerCommit,
    };
}
exports.coerceUserCreatePullRequestOptions = coerceUserCreatePullRequestOptions;
/**
 * map yargs to user pull request otions
 */
function coerceUserCreateReviewRequestOptions() {
    return {
        repo: yargs.argv.upstreamRepo,
        owner: yargs.argv.upstreamOwner,
        pullNumber: yargs.argv.pullNumber,
        logger: logger_1.logger,
    };
}
exports.coerceUserCreateReviewRequestOptions = coerceUserCreateReviewRequestOptions;
async function createCommand() {
    const options = coerceUserCreatePullRequestOptions();
    const changes = await git.getChanges(yargs.argv['git-dir']);
    const octokit = new rest_1.Octokit({ auth: process.env.ACCESS_TOKEN });
    await (0, __1.createPullRequest)(octokit, changes, options);
}
async function reviewCommand() {
    const reviewOptions = coerceUserCreateReviewRequestOptions();
    const diffContents = await git.getDiffString(yargs.argv['git-dir']);
    const octokit = new rest_1.Octokit({ auth: process.env.ACCESS_TOKEN });
    await (0, __1.reviewPullRequest)(octokit, diffContents, reviewOptions);
}
/**
 * main workflow entrance
 */
async function main() {
    try {
        (0, logger_1.setupLogger)(console);
        if (!process.env.ACCESS_TOKEN) {
            throw Error('The ACCESS_TOKEN should not be undefined');
        }
        switch (yargs.argv._[0]) {
            case exports.CREATE_PR_COMMAND:
                await createCommand();
                break;
            case exports.REVIEW_PR_COMMAND:
                await reviewCommand();
                break;
            default:
                // yargs should have caught this.
                throw Error(`Unhandled command detected: ${yargs.argv._[0]}`);
        }
    }
    catch (err) {
        logger_1.logger.error('Workflow failed');
        throw err;
    }
}
exports.main = main;
//# sourceMappingURL=workflow.js.map
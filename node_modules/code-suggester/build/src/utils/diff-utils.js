"use strict";
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSuggestedHunks = exports.parseAllHunks = exports.parsePatch = void 0;
const parseDiff = require("parse-diff");
const diff_1 = require("diff");
// This header is ignored for calculating patch ranges, but is neccessary
// for parsing a diff
const _DIFF_HEADER = `diff --git a/file.ext b/file.ext
index cac8fbc..87f387c 100644
--- a/file.ext
+++ b/file.ext
`;
/**
 * Given a patch expressed in GNU diff format, return the range of lines
 * from the original content that are changed.
 * @param diff Diff expressed in GNU diff format.
 * @returns Hunk[]
 */
function parsePatch(patch) {
    return parseAllHunks(_DIFF_HEADER + patch).get('file.ext') || [];
}
exports.parsePatch = parsePatch;
/**
 * Given a diff expressed in GNU diff format, return the range of lines
 * from the original content that are changed.
 * @param diff Diff expressed in GNU diff format.
 * @returns Map<string, Hunk[]>
 */
function parseAllHunks(diff) {
    const hunksByFile = new Map();
    parseDiff(diff).forEach(file => {
        const filename = file.to ? file.to : file.from;
        const chunks = file.chunks.map(chunk => {
            let oldStart = chunk.oldStart;
            let newStart = chunk.newStart;
            let normalLines = 0;
            let changeSeen = false;
            const newLines = [];
            let previousLine = null;
            let nextLine = null;
            chunk.changes.forEach(change => {
                // strip off leading '+', '-', or ' ' and trailing carriage return
                const content = change.content.substring(1).replace(/[\n\r]+$/g, '');
                if (change.type === 'normal') {
                    normalLines++;
                    if (changeSeen) {
                        if (nextLine === null) {
                            nextLine = content;
                        }
                    }
                    else {
                        previousLine = content;
                    }
                }
                else {
                    if (change.type === 'add') {
                        // strip off leading '+' and trailing carriage return
                        newLines.push(content);
                    }
                    if (!changeSeen) {
                        oldStart += normalLines;
                        newStart += normalLines;
                        changeSeen = true;
                    }
                }
            });
            const newEnd = newStart + chunk.newLines - normalLines - 1;
            const oldEnd = oldStart + chunk.oldLines - normalLines - 1;
            let hunk = {
                oldStart: oldStart,
                oldEnd: oldEnd,
                newStart: newStart,
                newEnd: newEnd,
                newContent: newLines,
            };
            if (previousLine) {
                hunk = { ...hunk, previousLine: previousLine };
            }
            if (nextLine) {
                hunk = { ...hunk, nextLine: nextLine };
            }
            return hunk;
        });
        hunksByFile.set(filename, chunks);
    });
    return hunksByFile;
}
exports.parseAllHunks = parseAllHunks;
/**
 * Given two texts, return the range of lines that are changed.
 * @param oldContent The original content.
 * @param newContent The new content.
 * @returns Hunk[]
 */
function getSuggestedHunks(oldContent, newContent) {
    const diff = (0, diff_1.createPatch)('unused', oldContent, newContent);
    return parseAllHunks(diff).get('unused') || [];
}
exports.getSuggestedHunks = getSuggestedHunks;
//# sourceMappingURL=diff-utils.js.map
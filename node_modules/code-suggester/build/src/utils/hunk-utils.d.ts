import { Hunk, FileDiffContent } from '../types';
/**
 * Shift a Hunk up one line so it starts one line earlier.
 * @param {Hunk} hunk
 * @returns {Hunk | null} the adjusted Hunk or null if there is no preceeding line.
 */
export declare function adjustHunkUp(hunk: Hunk): Hunk | null;
/**
 * Shift a Hunk up one line so it ends one line later.
 * @param {Hunk} hunk
 * @returns {Hunk | null} the adjusted Hunk or null if there is no following line.
 */
export declare function adjustHunkDown(hunk: Hunk): Hunk | null;
/**
 * Given a map where the key is the file name and the value is the
 * old content and new content of the file
 * compute the hunk for each file whose old and new contents differ.
 * Do not compute the hunk if the old content is the same as the new content.
 * The hunk list is sorted and each interval is disjoint.
 * @param {Map<string, FileDiffContent>} diffContents a map of the original file contents and the new file contents
 * @returns the hunks for each file whose old and new contents differ
 */
export declare function getRawSuggestionHunks(diffContents: Map<string, FileDiffContent>): Map<string, Hunk[]>;
interface PartitionedHunks {
    validHunks: Map<string, Hunk[]>;
    invalidHunks: Map<string, Hunk[]>;
}
/**
 * Split suggested hunks into commentable and non-commentable hunks. Compares the new line ranges
 * from pullRequestHunks against the old line ranges from allSuggestedHunks.
 * @param pullRequestHunks {Map<string, Hunk[]>} The parsed hunks from that represents the valid lines to comment.
 * @param allSuggestedHunks {Map<string, Hunk[]>} The hunks that represent suggested changes.
 * @returns {PartitionedHunks} split hunks
 */
export declare function partitionSuggestedHunksByScope(pullRequestHunks: Map<string, Hunk[]>, allSuggestedHunks: Map<string, Hunk[]>): PartitionedHunks;
export {};
